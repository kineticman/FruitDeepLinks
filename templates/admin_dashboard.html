<!DOCTYPE html>
<html>
<head>
<title>FruitDeepLinks Admin</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
background: #0f172a;
color: #e2e8f0;
padding: 20px;
}
.container { max-width: 1400px; margin: 0 auto; }
h1 { color: #60a5fa; margin-bottom: 10px; }
.subtitle { color: #94a3b8; margin-bottom: 30px; }
.grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-bottom: 30px; }
.card {
background: #1e293b;
border: 1px solid #334155;
border-radius: 8px;
padding: 20px;
}
.card h2 { color: #60a5fa; font-size: 18px; margin-bottom: 15px; }
.stat { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #334155; }
.stat:last-child { border-bottom: none; }
.stat-label { color: #94a3b8; }
.stat-value { color: #e2e8f0; font-weight: 600; }
.btn {
background: #3b82f6;
color: white;
border: none;
padding: 10px 20px;
border-radius: 6px;
cursor: pointer;
font-size: 14px;
margin-right: 10px;
}
.btn:hover { background: #2563eb; }
.btn:disabled { background: #475569; cursor: not-allowed; }
.btn-secondary { background: #64748b; }
.btn-secondary:hover { background: #475569; }
.btn-danger { background: #dc2626; }
.btn-danger:hover { background: #b91c1c; }
.log-container {
background: #0f172a;
border: 1px solid #334155;
border-radius: 8px;
padding: 15px;
height: 400px;
overflow-y: auto;
font-family: 'Courier New', monospace;
font-size: 13px;
}
.log-line { padding: 2px 0; color: #cbd5e1; }
.log-line:hover { background: #1e293b; }
.status-running { color: #fbbf24; }
.status-success { color: #34d399; }
.status-failed { color: #f87171; }

.provider-lanes-table {
width: 100%;
border-collapse: collapse;
margin-top: 10px;
font-size: 14px;
}
.provider-lanes-table th,
.provider-lanes-table td {
border-bottom: 1px solid #334155;
padding: 8px 6px;
text-align: left;
}
.provider-lanes-table th {
font-weight: 600;
color: #e2e8f0;
background: #0f172a;
}
.provider-lanes-table tr:hover {
background: #111827;
}
.provider-lanes-table input[type="number"] {
width: 80px;
padding: 4px 6px;
border-radius: 4px;
border: 1px solid #334155;
background: #020617;
color: #e2e8f0;
}

.file-list { list-style: none; }
.file-item { padding: 8px 0; border-bottom: 1px solid #334155; display: flex; justify-content: space-between; }
.file-item:last-child { border-bottom: none; }
.file-name { color: #60a5fa; }
.file-size { color: #94a3b8; font-size: 12px; }
.loading { color: #fbbf24; }
</style>
</head>
<body>
<div class="container">
<h1>FruitDeepLinks Admin</h1>
<p class="subtitle">Multi-source sports event aggregator</p>

<div class="nav-bar">
<a href="/filters" class="btn btn-secondary">üéõÔ∏è Filters & Settings</a>
<a href="/events" class="btn btn-secondary">üîé Event Inspector</a>
<a href="/adb" class="btn btn-secondary">üì∫ ADB Configuration</a>
<a href="/api" class="btn btn-secondary">üì° API Helper</a>
</div>

<div class="grid">
<div class="card">
<h2>Database Stats</h2>
<div id="db-stats">Loading...</div>
</div>

<div class="card">
<h2>Output Files</h2>
<div id="file-list">Loading...</div>
</div>

<div class="card">
<h2>Environment Variables</h2>
<div id="env-vars">Loading...</div>
</div>

<div class="card">
<h2>Refresh Control</h2>
<div id="refresh-status" style="margin-bottom: 15px;">Loading...</div>
<button class="btn" onclick="triggerRefresh(false)" id="btn-refresh"> Full Refresh</button>
<button class="btn btn-secondary" onclick="triggerRefresh(true)" id="btn-refresh-skip"> Skip Scrape</button>

<div style="margin-top:15px; padding-top:15px; border-top:1px solid #334155;">
<h3 style="font-size:15px; margin-bottom:8px;">Database Management</h3>
<button class="btn btn-danger" onclick="wipeEventData()" id="btn-wipe-db">üóëÔ∏è Wipe Event Data</button>
<p style="font-size:12px; color:#94a3b8; margin-top:8px;">Clears all events, playables, and lanes. Preserves filters and settings.</p>
</div>

<div style="margin-top:15px; padding-top:15px; border-top:1px solid #334155;">
<h3 style="font-size:15px; margin-bottom:8px;">Auto Refresh</h3>
<div style="margin-bottom:8px;">
<label class="stat-label">
Time (local):
<input type="time" id="auto-time" style="margin-left:8px; padding:4px; border-radius:4px; border:1px solid #334155; background:#0f172a; color:#e2e8f0;">
</label>
</div>
<div style="margin-bottom:8px;">
<label class="stat-label">
<input type="checkbox" id="auto-enabled" style="margin-right:6px;">
Enable daily auto refresh
</label>
</div>
<div class="stat-label" id="auto-next-run"></div>
<div style="margin-top:10px;">
<button class="btn btn-secondary" onclick="saveAutoRefresh()" id="btn-save-auto"> Save Auto Settings</button>
</div>
</div>
</div>
</div>

<div class="card">
<h2>Live Logs <span class="loading" id="log-status"></span></h2>
<div class="log-container" id="log-container"></div>
</div>
</div>

<script>
let logEventSource;

async function loadStatus() {
try {
const res = await fetch('/api/status');
if (!res.ok) {
throw new Error(`HTTP ${res.status}: ${res.statusText}`);
}
const data = await res.json();

// Database stats
const dbStats = document.getElementById('db-stats');
if (data.database.error) {
dbStats.innerHTML = `<div class="stat-value" style="color: #f87171;">Error: ${data.database.error}</div>`;
} else {
const db = data.database;
const dbMod = db.db_modified ? new Date(db.db_modified).toLocaleString() : 'n/a';
const dbSize = db.db_size ? (db.db_size / 1024 / 1024).toFixed(2) + ' MB' : 'n/a';
dbStats.innerHTML = `
<div class="stat"><span class="stat-label">Total Events</span><span class="stat-value">${db.total_events || 0}</span></div>
<div class="stat"><span class="stat-label">Future Events</span><span class="stat-value">${db.future_events || 0}</span></div>
<div class="stat"><span class="stat-label">Lanes</span><span class="stat-value">${db.lane_count || 0}</span></div>
<div class="stat"><span class="stat-label">Scheduled</span><span class="stat-value">${db.scheduled_events || 0}</span></div>
<div class="stat"><span class="stat-label">DB Last Updated</span><span class="stat-value">${dbMod}</span></div>
<div class="stat"><span class="stat-label">DB Size</span><span class="stat-value">${dbSize}</span></div>
`;
}

// Files
const fileList = document.getElementById('file-list');
const files = Object.entries(data.files || {});
if (files.length === 0) {
fileList.innerHTML = '<p class="stat-value">No files generated yet</p>';
} else {
fileList.innerHTML = '<ul class="file-list">' + files.map(([name, info]) => `
<li class="file-item">
<a href="/out/${name}" class="file-name">${name}</a>
<span class="file-size">${(info.size / 1024 / 1024).toFixed(2)} MB</span>
</li>
`).join('') + '</ul>';
}

// Refresh status
const refreshStatus = document.getElementById('refresh-status');
const refresh = data.refresh;
const btnRefresh = document.getElementById('btn-refresh');
const btnRefreshSkip = document.getElementById('btn-refresh-skip');

if (refresh.running) {
refreshStatus.innerHTML = `<span class="status-running"> Running: ${refresh.current_step || 'Processing...'}</span>`;
btnRefresh.disabled = true;
btnRefreshSkip.disabled = true;
} else {
btnRefresh.disabled = false;
btnRefreshSkip.disabled = false;

const pieces = [];
if (refresh.last_run_manual) {
const manualStatus = refresh.last_status_manual || refresh.last_status;
let manualBadge = '';
if (manualStatus === 'success') {
manualBadge = '<span class="status-success">Success</span>';
} else if (manualStatus) {
manualBadge = '<span class="status-failed"> ' + manualStatus + '</span>';
}
pieces.push('Last manual refresh: ' + new Date(refresh.last_run_manual).toLocaleString() + ' ' + manualBadge);
}
if (refresh.last_run_auto) {
const autoStatus = refresh.last_status_auto;
let autoBadge = '';
if (autoStatus === 'success') {
autoBadge = '<span class="status-success">Success</span>';
} else if (autoStatus) {
autoBadge = '<span class="status-failed"> ' + autoStatus + '</span>';
}
pieces.push('Last auto refresh: ' + new Date(refresh.last_run_auto).toLocaleString() + ' ' + autoBadge);
}
if (!pieces.length && refresh.last_run) {
const status = refresh.last_status === 'success' 
? '<span class="status-success">Success</span>'
: refresh.last_status
? '<span class="status-failed"> ' + refresh.last_status + '</span>'
: '';
pieces.push('Last refresh: ' + new Date(refresh.last_run).toLocaleString() + ' ' + status);
}
refreshStatus.innerHTML = pieces.length ? pieces.join('<br>') : 'No refresh run yet';
}

// Auto-refresh status block
if (data.auto_refresh) {
applyAutoSettingsToDom(data.auto_refresh);
}

// Environment variables
const envVars = document.getElementById('env-vars');
if (data.env_vars && Object.keys(data.env_vars).length > 0) {
const envEntries = Object.entries(data.env_vars)
.sort(([a], [b]) => a.localeCompare(b))
.map(([key, val]) => {
// Mask sensitive values
let displayVal = val;
if (key.toLowerCase().includes('key') || key.toLowerCase().includes('secret') || key.toLowerCase().includes('password')) {
displayVal = '********';
}
// Truncate long values
if (displayVal && displayVal.length > 60) {
displayVal = displayVal.substring(0, 57) + '...';
}
return `<div class="stat"><span class="stat-label">${key}</span><span class="stat-value" style="font-size: 12px; font-family: monospace;">${displayVal || '(empty)'}</span></div>`;
}).join('');
envVars.innerHTML = envEntries;
} else {
envVars.innerHTML = '<div class="stat-value" style="color: #94a3b8;">No environment variables configured</div>';
}

} catch (err) {
console.error('Failed to load status:', err);
document.getElementById('db-stats').innerHTML = `<div style="color: #f87171;">API Error: ${err.message}</div>`;
document.getElementById('file-list').innerHTML = `<div style="color: #f87171;">Failed to load files</div>`;
document.getElementById('refresh-status').innerHTML = `<div style="color: #f87171;">Status unavailable</div>`;
}
}

async function triggerRefresh(skipScrape) {
try {
const res = await fetch('/api/refresh', {
method: 'POST',
headers: {'Content-Type': 'application/json'},
body: JSON.stringify({skip_scrape: skipScrape})
});

if (res.ok) {
document.getElementById('log-status').textContent = 'LIVE';
loadStatus();
} else {
const data = await res.json();
alert(data.error || 'Failed to start refresh');
}
} catch (err) {
alert('Error: ' + err.message);
}
}

async function saveAutoRefresh() {
try {
const enabled = document.getElementById('auto-enabled').checked;
const time = document.getElementById('auto-time').value || '02:30';
const res = await fetch('/api/auto-refresh', {
method: 'POST',
headers: {'Content-Type': 'application/json'},
body: JSON.stringify({ enabled, time })
});
if (!res.ok) {
const data = await res.json().catch(() => ({}));
alert(data.error || 'Failed to save auto-refresh settings');
return;
}
const dataJson = await res.json();
applyAutoSettingsToDom(dataJson);
} catch (err) {
alert('Error saving auto refresh: ' + err.message);
}
}

function applyAutoSettingsToDom(auto) {
const timeInput = document.getElementById('auto-time');
const enabledInput = document.getElementById('auto-enabled');
const label = document.getElementById('auto-next-run');

if (timeInput && document.activeElement !== timeInput) {
timeInput.value = auto.time || '02:30';
}
if (enabledInput && document.activeElement !== enabledInput) {
enabledInput.checked = !!auto.enabled;
}

if (auto.enabled) {
if (auto.next_run) {
label.textContent = 'Next auto run: ' + new Date(auto.next_run).toLocaleString();
} else {
label.textContent = 'Next auto run: scheduling...';
}
} else {
label.textContent = 'Auto refresh is disabled';
}
}

// ===================== Live Logs (sticky scroll + session restore) =====================
const LOG_MAX_LINES = 5000;              // keep this many lines in the DOM (increased for daily_refresh)
const LOG_TAIL_ON_CONNECT = 5000;       // server tail if we have no stored seq (increased from 500)
const AUTO_SCROLL_THRESHOLD_PX = 40;     // within this many px of bottom counts as "at bottom"
const LOG_STORE_KEY = "fdl_admin_live_logs_v1";      // sessionStorage cache of recent log lines
const LOG_STORE_SEQ_KEY = "fdl_admin_live_logs_seq"; // last seen seq (for SSE resume)
const LOG_STORE_SCROLL_KEY = "fdl_admin_live_logs_scroll"; // last scrollTop (when not at bottom)

let _logSaveTimer = null;
let _logLines = [];   // [{seq:number|null, text:string}]
let _lastSeq = 0;

function _loadLogsFromSession() {
  try {
    const raw = sessionStorage.getItem(LOG_STORE_KEY);
    const rawSeq = sessionStorage.getItem(LOG_STORE_SEQ_KEY);
    const rawScroll = sessionStorage.getItem(LOG_STORE_SCROLL_KEY);

    if (raw) {
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) _logLines = parsed.filter(x => x && typeof x.text === "string");
    }
    if (rawSeq) _lastSeq = parseInt(rawSeq, 10) || 0;

    return {
      hadLogs: _logLines.length > 0,
      lastSeq: _lastSeq,
      scrollTop: rawScroll ? (parseInt(rawScroll, 10) || 0) : 0,
    };
  } catch (e) {
    _logLines = [];
    _lastSeq = 0;
    return { hadLogs: false, lastSeq: 0, scrollTop: 0 };
  }
}

function _scheduleSaveLogsToSession() {
  // debounce writes to sessionStorage so we don't thrash it while logs spam
  if (_logSaveTimer) return;
  _logSaveTimer = setTimeout(() => {
    _logSaveTimer = null;
    try {
      // cap stored lines so sessionStorage stays sane
      const tail = _logLines.slice(-LOG_MAX_LINES);
      sessionStorage.setItem(LOG_STORE_KEY, JSON.stringify(tail));
      sessionStorage.setItem(LOG_STORE_SEQ_KEY, String(_lastSeq || 0));
    } catch (e) {
      // ignore storage failures
    }
  }, 250);
}

function _escapeHtml(s) {
  // avoid HTML injection in log rendering
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function _renderLogsIntoDom({ restoreScrollTop = null } = {}) {
  const container = document.getElementById("log-container");
  if (!container) return;

  const tail = _logLines.slice(-LOG_MAX_LINES);
  container.innerHTML = tail
    .map(x => `<div class="log-line" data-seq="${x.seq ?? ""}">${_escapeHtml(x.text)}</div>`)
    .join("");

  // If the user left while scrolled up, restore that scroll position.
  // Otherwise, default to bottom.
  if (typeof restoreScrollTop === "number" && restoreScrollTop > 0) {
    container.scrollTop = Math.min(restoreScrollTop, container.scrollHeight);
  } else {
    container.scrollTop = container.scrollHeight;
  }
}

function _isAtBottom(container) {
  const distanceFromBottom = container.scrollHeight - container.scrollTop - container.clientHeight;
  return distanceFromBottom <= AUTO_SCROLL_THRESHOLD_PX;
}

function _appendLogLineToDom(textLine, seqOrNull) {
  const container = document.getElementById("log-container");
  if (!container) return;

  const wasAtBottom = _isAtBottom(container);
  const prevScrollTop = container.scrollTop;

  const line = document.createElement("div");
  line.className = "log-line";
  if (seqOrNull != null) line.dataset.seq = String(seqOrNull);
  line.textContent = textLine; // safe, no HTML parsing
  container.appendChild(line);

  // Trim DOM lines (from the top)
  while (container.children.length > LOG_MAX_LINES) {
    container.removeChild(container.firstChild);
  }

  // Sticky scroll behavior:
  // - If user is reading older lines (not at bottom), keep them where they are.
  // - If they're at bottom, follow new lines.
  if (wasAtBottom) {
    container.scrollTop = container.scrollHeight;
  } else {
    container.scrollTop = prevScrollTop;
    try {
      sessionStorage.setItem(LOG_STORE_SCROLL_KEY, String(container.scrollTop));
    } catch (e) {}
  }
}

function _addLogLine(textLine, seqOrNull) {
  if (!textLine) return;

  const seq = (seqOrNull != null) ? (parseInt(seqOrNull, 10) || 0) : 0;
  if (seq > 0) _lastSeq = Math.max(_lastSeq, seq);

  _logLines.push({ seq: seq > 0 ? seq : null, text: textLine });
  if (_logLines.length > LOG_MAX_LINES) _logLines = _logLines.slice(-LOG_MAX_LINES);

  _appendLogLineToDom(textLine, seq > 0 ? seq : null);
  _scheduleSaveLogsToSession();
}

function setupLogStream() {
  if (logEventSource) logEventSource.close();

  const statusEl = document.getElementById("log-status");
  if (statusEl) statusEl.textContent = "CONNECTING‚Ä¶";

  const hasSeq = (_lastSeq && _lastSeq > 0);
  const qs = new URLSearchParams();
  if (hasSeq) {
    qs.set("since", String(_lastSeq));
  } else {
    // no seq known -> ask server to tail some lines so we immediately see history
    qs.set("tail", String(LOG_TAIL_ON_CONNECT));
  }

  logEventSource = new EventSource(`/api/logs/stream?${qs.toString()}`);
  const container = document.getElementById("log-container");

  // Persist scroll position when user scrolls up (and restore it on return)
  if (container) {
    container.addEventListener("scroll", () => {
      if (!_isAtBottom(container)) {
        try { sessionStorage.setItem(LOG_STORE_SCROLL_KEY, String(container.scrollTop)); } catch (e) {}
      } else {
        try { sessionStorage.removeItem(LOG_STORE_SCROLL_KEY); } catch (e) {}
      }
    }, { passive: true });
  }

  logEventSource.onmessage = (event) => {
    let lineText = "";
    let seq = null;

    try {
      const obj = JSON.parse(event.data);
      lineText = (obj && (obj.log ?? obj.line)) ? (obj.log ?? obj.line) : String(event.data || "");
      if (obj && typeof obj.seq !== "undefined") seq = obj.seq;
    } catch (e) {
      // Backwards-compatible: server may stream plain-text lines
      lineText = String(event.data || "");
    }

    if (!lineText) return;
    _addLogLine(lineText, seq);
  };

  logEventSource.addEventListener("ping", () => {
    // keep-alive heartbeat
  });

  logEventSource.onerror = () => {
    if (statusEl) statusEl.textContent = "RECONNECTING‚Ä¶";
    try { logEventSource.close(); } catch (e) {}
    setTimeout(setupLogStream, 2000);
  };

  if (statusEl) statusEl.textContent = "LIVE";
}

async function loadInitialLogs() {
  // Prefer restoring from sessionStorage so navigating away/back preserves what you were reading.
  const restored = _loadLogsFromSession();
  _renderLogsIntoDom({ restoreScrollTop: restored.scrollTop });

  // If nothing was restored, do a one-shot pull for quick history (plain lines),
  // then SSE will take over and include seqs.
  if (!restored.hadLogs) {
    try {
      const res = await fetch(`/api/logs?count=${LOG_TAIL_ON_CONNECT}`);
      const data = await res.json();
      if (Array.isArray(data.logs)) {
        data.logs.forEach((t) => {
          if (typeof t === "string" && t.trim()) _logLines.push({ seq: null, text: t });
        });
        _logLines = _logLines.slice(-LOG_MAX_LINES);
        _renderLogsIntoDom();
        _scheduleSaveLogsToSession();
      }
    } catch (e) {
      // ignore
    }
  }
}

async function wipeEventData() {
try {
const confirmed = confirm(
'‚ö†Ô∏è WARNING: This will DELETE all event data!\n\n' +
'This will clear:\n' +
'‚Ä¢ All events and playables\n' +
'‚Ä¢ All lanes (Fruit Lanes, ADB Lanes)\n' +
'‚Ä¢ Apple & ESPN cached data\n' +
'‚Ä¢ Amazon scraped channels\n\n' +
'This will PRESERVE:\n' +
'‚úì Filter settings\n' +
'‚úì User preferences\n' +
'‚úì ADB configuration\n' +
'‚úì Amazon service definitions\n\n' +
'Are you sure you want to continue?'
);

if (!confirmed) return;

const doubleCheck = confirm(
'‚ö†Ô∏è FINAL CONFIRMATION\n\n' +
'This action cannot be undone!\n\n' +
'Type YES in the next prompt to proceed.'
);

if (!doubleCheck) return;

const verification = prompt('Type YES (in capitals) to confirm:');
if (verification !== 'YES') {
alert('Wipe cancelled - verification failed');
return;
}

document.getElementById('btn-wipe-db').disabled = true;
document.getElementById('btn-wipe-db').textContent = '‚è≥ Wiping...';

const res = await fetch('/api/wipe-event-data', {
method: 'POST',
headers: {'Content-Type': 'application/json'}
});

if (!res.ok) {
const data = await res.json().catch(() => ({}));
alert(data.error || 'Failed to wipe event data');
document.getElementById('btn-wipe-db').disabled = false;
document.getElementById('btn-wipe-db').textContent = 'üóëÔ∏è Wipe Event Data';
return;
}

const result = await res.json();
alert('‚úÖ Event data wiped successfully!\n\n' + 
'Cleared:\n' + 
`‚Ä¢ ${result.events_deleted || 0} events\n` +
`‚Ä¢ ${result.playables_deleted || 0} playables\n` +
`‚Ä¢ ${result.lanes_deleted || 0} lanes\n\n` +
'Settings and filters preserved.');

loadStatus();
document.getElementById('btn-wipe-db').disabled = false;
document.getElementById('btn-wipe-db').textContent = 'üóëÔ∏è Wipe Event Data';
} catch (err) {
alert('Error wiping event data: ' + err.message);
document.getElementById('btn-wipe-db').disabled = false;
document.getElementById('btn-wipe-db').textContent = 'üóëÔ∏è Wipe Event Data';
}
}

// Initialize
loadStatus();
loadInitialLogs();
setupLogStream();
setInterval(loadStatus, 5000);
</script>
</body>
</html>
